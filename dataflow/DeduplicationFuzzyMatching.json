{
	"name": "DeduplicationFuzzyMatching",
	"properties": {
		"type": "MappingDataFlow",
		"typeProperties": {
			"sources": [
				{
					"dataset": {
						"referenceName": "adlsgen2employee",
						"type": "DatasetReference"
					},
					"name": "sourceName"
				}
			],
			"sinks": [
				{
					"dataset": {
						"referenceName": "adlsgen2exployeedupes",
						"type": "DatasetReference"
					},
					"name": "SinkDupes"
				},
				{
					"dataset": {
						"referenceName": "adlsgen2exployeededupes",
						"type": "DatasetReference"
					},
					"name": "SinkNotDupes"
				}
			],
			"transformations": [
				{
					"name": "CreateFullName"
				},
				{
					"name": "MapNames"
				},
				{
					"name": "FuzzyMatch"
				},
				{
					"name": "Orig1"
				},
				{
					"name": "SoundexBranch"
				},
				{
					"name": "GroupSoundex"
				},
				{
					"name": "SoundexJoin"
				},
				{
					"name": "PhoneBranch"
				},
				{
					"name": "GroupPhone"
				},
				{
					"name": "PhoneJoin"
				},
				{
					"name": "ZipBranch"
				},
				{
					"name": "GroupZip"
				},
				{
					"name": "ZipJoin"
				},
				{
					"name": "SetConstants"
				},
				{
					"name": "MatchScore"
				},
				{
					"name": "CheckForDupes"
				},
				{
					"name": "FinalResult"
				}
			],
			"scriptLines": [
				"source(output(",
				"          {Emp ID} as string,",
				"          {Name Prefix} as string,",
				"          {First Name} as string,",
				"          {Middle Initial} as string,",
				"          {Last Name} as string,",
				"          Gender as string,",
				"          {E Mail} as string,",
				"          {Father's Name} as string,",
				"          {Mother's Name} as string,",
				"          {Mother's Maiden Name} as string,",
				"          {Date of Birth} as string,",
				"          {Time of Birth} as string,",
				"          {Age in Yrs.} as string,",
				"          {Weight in Kgs.} as string,",
				"          {Date of Joining} as string,",
				"          {Quarter of Joining} as string,",
				"          {Half of Joining} as string,",
				"          {Year of Joining} as string,",
				"          {Month of Joining} as string,",
				"          {Month Name of Joining} as string,",
				"          {Short Month} as string,",
				"          {Day of Joining} as string,",
				"          {DOW of Joining} as string,",
				"          {Short DOW} as string,",
				"          {Age in Company (Years)} as string,",
				"          Salary as string,",
				"          {Last % Hike} as string,",
				"          SSN as string,",
				"          {Phone No. } as string,",
				"          {Place Name} as string,",
				"          County as string,",
				"          City as string,",
				"          State as string,",
				"          Zip as string,",
				"          Region as string,",
				"          {User Name} as string,",
				"          Password as string",
				"     ),",
				"     allowSchemaDrift: true,",
				"     validateSchema: false,",
				"     ignoreNoFilesFound: false) ~> sourceName",
				"sourceName derive(fullname = concat({First Name},{Last Name})) ~> CreateFullName",
				"CreateFullName select(mapColumn(",
				"          each(match(instr(lower(name), 'phone')>0),",
				"               'phone' = $$),",
				"          each(match(instr(lower(name), 'zip')>0),",
				"               'zip' = $$),",
				"          each(match(instr(lower(name), 'fullname')>0),",
				"               'fullname' = $$),",
				"          each(match(instr(lower(name),'id')>0),",
				"               'acctnum' = $$)",
				"     ),",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true) ~> MapNames",
				"MapNames derive(SoundexValue = soundex(fullname)) ~> FuzzyMatch",
				"FuzzyMatch select(mapColumn(",
				"          acctnum,",
				"          phone,",
				"          zip,",
				"          fullname,",
				"          SoundexValue",
				"     ),",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true) ~> Orig1",
				"FuzzyMatch select(mapColumn(",
				"          phone,",
				"          zip,",
				"          fullname,",
				"          acctnum,",
				"          SoundexValue",
				"     ),",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true) ~> SoundexBranch",
				"Orig1 aggregate(groupBy(SoundexValue),",
				"     soundexmatch = sum(1)) ~> GroupSoundex",
				"GroupSoundex, SoundexBranch join(GroupSoundex@SoundexValue == SoundexBranch@SoundexValue,",
				"     joinType:'inner',",
				"     matchType:'exact',",
				"     ignoreSpaces: false,",
				"     broadcast: 'auto')~> SoundexJoin",
				"SoundexJoin select(mapColumn(",
				"          SoundexValue = GroupSoundex@SoundexValue,",
				"          soundexmatch,",
				"          phone,",
				"          zip,",
				"          fullname,",
				"          acctnum",
				"     ),",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true) ~> PhoneBranch",
				"SoundexJoin aggregate(groupBy(phone,",
				"          GroupSoundex@SoundexValue),",
				"     phonematch = sum(1),",
				"          acctnum_agg = last(acctnum)) ~> GroupPhone",
				"GroupPhone, PhoneBranch join(acctnum_agg == acctnum,",
				"     joinType:'right',",
				"     matchType:'exact',",
				"     ignoreSpaces: false,",
				"     broadcast: 'auto')~> PhoneJoin",
				"PhoneJoin select(mapColumn(",
				"          phone = GroupPhone@phone,",
				"          SoundexValue = GroupPhone@SoundexValue,",
				"          phonematch,",
				"          soundexmatch,",
				"          zip,",
				"          fullname,",
				"          acctnum",
				"     ),",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true) ~> ZipBranch",
				"PhoneJoin aggregate(groupBy(GroupPhone@SoundexValue,",
				"          zip),",
				"     zipcount = sum(1),",
				"          acctnum_agg = last(acctnum_agg)) ~> GroupZip",
				"GroupZip, ZipBranch join(GroupZip@SoundexValue == ZipBranch@SoundexValue",
				"     && GroupZip@zip == ZipBranch@zip,",
				"     joinType:'right',",
				"     matchType:'exact',",
				"     ignoreSpaces: false,",
				"     broadcast: 'auto')~> ZipJoin",
				"ZipJoin derive(soundexweight = 50,",
				"          zipweight = 25,",
				"          phoneweight = 25,",
				"          soundexbool = iif(soundexmatch>1,1,0),",
				"          zipbool = iif(zipcount>1,1,0),",
				"          phonebool = iif(phonematch>1,1,0)) ~> SetConstants",
				"SetConstants derive(matchscore = (soundexbool * soundexweight) + (zipbool * zipweight) + (phonebool * phoneweight)) ~> MatchScore",
				"FinalResult split(matchscore>50,",
				"     disjoint: false) ~> CheckForDupes@(Duplicates, NotDupe)",
				"MatchScore select(mapColumn(",
				"          phone,",
				"          zip = GroupZip@zip,",
				"          fullname,",
				"          acctnum,",
				"          matchscore",
				"     ),",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true) ~> FinalResult",
				"CheckForDupes@Duplicates sink(allowSchemaDrift: true,",
				"     validateSchema: false,",
				"     umask: 0022,",
				"     preCommands: [],",
				"     postCommands: [],",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true) ~> SinkDupes",
				"CheckForDupes@NotDupe sink(allowSchemaDrift: true,",
				"     validateSchema: false,",
				"     umask: 0022,",
				"     preCommands: [],",
				"     postCommands: [],",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true) ~> SinkNotDupes"
			]
		}
	}
}